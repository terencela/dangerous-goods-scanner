/**
 * classifier.ts
 *
 * AI EXTRACTION ONLY — no verdicts generated by AI.
 * The AI's sole job is to read the image and return structured facts.
 * All verdicts are computed by the deterministic rules engine in rules.ts.
 *
 * This separation ensures zero-margin-for-error: an LLM cannot
 * hallucinate a verdict that contradicts official Zurich Airport policy.
 */

const CATEGORIES_INFO = [
  { id: 'battery-spare',             name: 'Spare Battery / Power Bank',           keywords: 'power bank, portable charger, spare battery, external battery, battery pack, powerbank' },
  { id: 'battery-installed',         name: 'Battery Installed in Device',           keywords: 'laptop battery, phone battery, tablet battery, device with built-in battery, camera battery' },
  { id: 'liquids',                   name: 'Liquids, Gels & Aerosols',              keywords: 'water, perfume, shampoo, lotion, gel, spray, deodorant, toothpaste, cream, drink, juice, oil, aerosol, cosmetic' },
  { id: 'knife',                     name: 'Knife',                                 keywords: 'knife, pocket knife, swiss army knife, utility knife, kitchen knife, hunting knife, penknife' },
  { id: 'scissors',                  name: 'Scissors',                              keywords: 'scissors, shears, craft scissors, nail scissors, cutting tool' },
  { id: 'tools',                     name: 'Tools (screwdrivers, wrenches, etc.)',  keywords: 'screwdriver, wrench, pliers, hammer, multi-tool, spanner, drill bit, chisel' },
  { id: 'lighter',                   name: 'Lighter',                               keywords: 'lighter, zippo, gas lighter, cigarette lighter, torch lighter, butane lighter' },
  { id: 'matches',                   name: 'Matches',                               keywords: 'matches, matchbox, matchstick, safety matches' },
  { id: 'e-cigarettes',              name: 'E-Cigarette / Vape',                    keywords: 'e-cigarette, vape, vaping device, e-pipe, juul, vape pen, iqos, electronic cigarette' },
  { id: 'electronics',              name: 'Laptop / Tablet / Phone / Camera',      keywords: 'laptop, tablet, phone, camera, smartphone, macbook, ipad, DSLR, gopro, kindle, e-reader' },
  { id: 'smart-luggage-removable',   name: 'Smart Luggage (removable battery)',     keywords: 'smart suitcase, smart luggage with removable battery, electronic luggage' },
  { id: 'smart-luggage-permanent',   name: 'Smart Luggage (built-in battery)',      keywords: 'smart suitcase with permanent battery, integrated battery suitcase' },
  { id: 'luggage-trackers',          name: 'Luggage Tracker (AirTag, Tile, etc.)', keywords: 'airtag, tile tracker, luggage tracker, gps tracker, apple airtag' },
  { id: 'electronic-bag-tags',       name: 'Electronic Bag Tags (EBTS)',            keywords: 'electronic bag tag, EBTS, e-tag, digital luggage tag' },
  { id: 'blunt-objects',             name: 'Blunt Objects (bats, clubs, hammers)', keywords: 'baseball bat, golf club, hammer, cricket bat, hockey stick, baton, club' },
  { id: 'sports-equipment',          name: 'Sports Equipment (rackets, poles)',     keywords: 'tennis racket, badminton racket, ski poles, hiking poles, racket, fishing rod, bow' },
  { id: 'fireworks',                 name: 'Fireworks / Sparklers',                 keywords: 'fireworks, sparklers, firecrackers, pyrotechnics, bengal fire' },
  { id: 'fuel-paste',                name: 'Fuel Paste / Flammable Liquids',        keywords: 'fuel, gasoline, lighter fluid, flammable liquid, fuel paste, chafing fuel, solid fuel' },
  { id: 'toxic-corrosive',           name: 'Acids / Toxic / Corrosive',             keywords: 'acid, bleach, corrosive, toxic chemical, poison, lye, sulfuric acid' },
  { id: 'gas-cartridges',            name: 'Gas Cartridges / Compressed Gas',       keywords: 'gas cartridge, compressed gas, propane, butane, pepper spray, CO2 cartridge, aerosol can' },
  { id: 'paints',                    name: 'Paints / Solvents',                     keywords: 'paint, paint thinner, solvent, turpentine, acetone, nail polish remover, lacquer' },
];

/**
 * EXTRACTION-ONLY prompt.
 * The AI reads the image and returns FACTS ONLY.
 * It must NOT generate verdicts, recommendations, or allowed/not_allowed decisions.
 * Those are handled exclusively by the deterministic rules engine.
 */
const EXTRACTION_PROMPT = `You are a baggage scanner AI assistant for Zurich Airport. Your ONLY job is to identify items in photos and extract measurable technical facts from labels. You do NOT decide if items are allowed or not – that is handled by a separate rules engine.

AVAILABLE CATEGORIES (pick the closest match):
${CATEGORIES_INFO.map(c => `- ID: "${c.id}" | Name: "${c.name}" | Keywords: ${c.keywords}`).join('\n')}

YOUR TASK:
1. Look at the photo and identify the item as precisely as possible
2. Read ALL text labels, markings, and specifications visible in the image
3. Extract every measurable technical property you can read (mAh, Wh, V, ml, cm, L, oz)
4. NEVER guess verdicts, NEVER say "allowed" or "not allowed"
5. Be honest about confidence: only set high if you are very certain of both category AND properties

CONFIDENCE RULES (follow strictly):
- "high": Item clearly visible AND category unambiguous AND all critical numbers readable from label
- "medium": Item identifiable but some properties unclear or partially obscured
- "low": Item hard to identify, blurry, or insufficient label detail

RESPOND ONLY with valid JSON, no markdown, no backticks:
{
  "identified": true,
  "itemName": "Precise descriptive name, e.g. 'Anker 20,000mAh USB-C Power Bank'",
  "categoryId": "one of the IDs listed above",
  "confidence": "high" | "medium" | "low",
  "detectedProperties": {
    "mah": <number read from label, or null if not visible>,
    "voltage": <number in Volts, or null>,
    "wh": <number in Watt-hours, or null — COMPUTE from mAh×V/1000 if both visible>,
    "volume_ml": <number in ml, or null — convert from L or oz if needed>,
    "blade_length_cm": <estimated blade length in cm, or null>,
    "isLithiumIon": <true if label says Li-ion, Li-Po, lithium, or null if unknown>
  },
  "missingCriticalData": <true if the item needs data (e.g. Wh for battery) that you cannot read from the label>,
  "summary": "One sentence: what you see and what technical data you found or couldn't find"
}

If item cannot be identified at all:
{"identified": false, "summary": "Brief explanation of why not identifiable (blurry, obscured, etc.)"}

RULES FOR SPECIFIC CATEGORIES:
- battery-spare / battery-installed: ALWAYS try to read mAh and V from label. Compute Wh = mAh × V / 1000. If you cannot read Wh or mAh+V, set missingCriticalData=true
- liquids: ALWAYS try to read volume from label (ml, L, fl oz). If not readable, set missingCriticalData=true  
- knife / scissors / tools: Estimate blade/shaft length in cm visually. Set missingCriticalData=true if impossible to estimate
- Do NOT set missingCriticalData for items with static rules (lighter, matches, fireworks, etc.)`;

export interface AiExtraction {
  identified: boolean;
  itemName?: string;
  categoryId?: string;
  confidence?: 'high' | 'medium' | 'low';
  detectedProperties?: {
    mah?: number | null;
    voltage?: number | null;
    wh?: number | null;
    volume_ml?: number | null;
    blade_length_cm?: number | null;
    isLithiumIon?: boolean | null;
  };
  missingCriticalData?: boolean;
  summary?: string;
  error?: string;
}

// Legacy alias kept for backward compat with AppContext/ResultScreen
export type AiAnalysis = AiExtraction;

export async function classifyWithVision(
  base64DataUrl: string,
  apiKey: string
): Promise<AiExtraction> {
  try {
    const res = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: EXTRACTION_PROMPT },
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: 'Please identify this item and extract all technical specifications from the label.',
              },
              {
                type: 'image_url',
                image_url: { url: base64DataUrl, detail: 'high' },
              },
            ],
          },
        ],
        max_tokens: 600,
        temperature: 0.0, // zero temperature for maximum determinism
      }),
    });

    if (!res.ok) {
      const errBody = await res.json().catch(() => null);
      if (res.status === 401) return { identified: false, error: 'Invalid API key. Check your OpenAI key in Settings.' };
      if (res.status === 429) return { identified: false, error: 'Rate limit reached. Please wait and try again.' };
      return { identified: false, error: errBody?.error?.message || `API error (${res.status})` };
    }

    const data = await res.json();
    const content: string = data.choices?.[0]?.message?.content || '';
    const cleaned = content.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
    const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return { identified: false, error: 'Could not parse AI response.' };

    return JSON.parse(jsonMatch[0]) as AiExtraction;
  } catch (err) {
    return {
      identified: false,
      error: err instanceof Error ? err.message : 'Network error. Check your connection.',
    };
  }
}

/**
 * Text-based extraction for chatbot mode.
 * Parses a free-text user question into structured facts for the rules engine.
 */
const CHAT_EXTRACTION_PROMPT = `You are a baggage assistant for Zurich Airport. A traveller has asked you a question about what they can bring on their flight.

Your job is to extract structured facts from their question to feed into a rule engine.

AVAILABLE CATEGORIES:
${CATEGORIES_INFO.map(c => `- ID: "${c.id}" | "${c.name}"`).join('\n')}

Extract and return ONLY a JSON object with what you can determine. Set fields to null if not mentioned:
{
  "categoryId": "best matching category ID or null",
  "itemName": "how the user described the item",
  "detectedProperties": {
    "mah": <number or null>,
    "voltage": <number or null>,
    "wh": <number or null — compute from mAh×V/1000 if both given>,
    "volume_ml": <number or null — convert L→ml, oz→ml if needed>,
    "blade_length_cm": <number or null>,
    "isLithiumIon": <true/false/null>
  },
  "missingCriticalData": <true if category requires properties that user didn't mention>,
  "clarificationNeeded": <null, or a very short question to ask the user to get the missing data>,
  "confidence": "high" | "medium" | "low"
}`;

export async function extractFromText(
  userMessage: string,
  apiKey: string
): Promise<AiExtraction & { clarificationNeeded?: string | null }> {
  try {
    const res = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: CHAT_EXTRACTION_PROMPT },
          { role: 'user', content: userMessage },
        ],
        max_tokens: 400,
        temperature: 0.0,
      }),
    });

    if (!res.ok) {
      const errBody = await res.json().catch(() => null);
      return { identified: false, error: errBody?.error?.message || `API error (${res.status})` };
    }

    const data = await res.json();
    const content: string = data.choices?.[0]?.message?.content || '';
    const cleaned = content.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
    const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return { identified: false, error: 'Could not parse response.' };

    const parsed = JSON.parse(jsonMatch[0]);
    return {
      identified: !!parsed.categoryId,
      itemName: parsed.itemName,
      categoryId: parsed.categoryId,
      confidence: parsed.confidence || 'medium',
      detectedProperties: parsed.detectedProperties,
      missingCriticalData: parsed.missingCriticalData,
      summary: parsed.itemName,
      clarificationNeeded: parsed.clarificationNeeded,
    };
  } catch (err) {
    return {
      identified: false,
      error: err instanceof Error ? err.message : 'Network error.',
    };
  }
}
